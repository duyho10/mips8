module mips8( input clk,reset,  
                           output[7:0] pc_out, alu_result
                           
   );  
wire [15:0] instr;
wire [15:0] instr;  
 wire reg_dst,mem_to_reg;  
 wire jump,branch,mem_read,mem_write,alu_src,reg_write     ;  
 wire     [2:0]     write_reg_address;      // lua chon dia chi rd
 wire     [7:0]     write_reg_data; //WD3 
 wire     [2:0]     reg_read_addr_A;  
 wire     [7:0]     reg_read_data_A;  //RD1
 wire     [2:0]     reg_read_addr_B;  
 wire     [7:0]     reg_read_data_B;  //RD2
 wire     [7:0]     sign_ext_im // output immediate 6bit -> 8bit
 wire     [2:0]     alu_op; // ALU opcode
 wire     [2:0]     ALU_Control; // Control ALU function
 wire     [7:0]     read_dataB; //Chon input B = reg hay bang immediate
 wire     [7:0]     ALU_out;
 wire               zero_flag;
 
 //
 wire [7:0] sign_ext_im,read_data2,zero_ext_im,imm_ext;  
 wire JRControl;  
 wire [2:0] ALU_Control;  
 wire [7:0] ALU_out;  
 wire zero_flag, cout;  
 wire signed[7:0] im_shift_1, PC_j, PC_beq, PC_4beq,PC_4beqj;  //PC_jr
 wire beq_control;  
 wire [6:0] jump_shift_1;  
 wire [7:0] mem_read_data;  
 wire [7:0] no_sign_ext;  
 //
 
 always @(posedge clk or posedge reset)  
 begin   
      if(reset)   
           pc_current <= 8'd0;  
      else  
           pc_current <= pc_next;  
 end  
 
 assign pc2 = pc_current + 8'd1; // Update PC
 
 instruction_memory instr_mem(.pc_input(pc_current),
                              .instruction_output(instr));  //in(out)
 assign jump_shift_1 = {instr[6:0],1'b0,1'b0}; // Shift left 2
 
 control_unit control(.reset(reset),.opcode(instr[14:12]),.reg_dst(reg_dst)  
                ,.mem_to_reg(mem_to_reg),.jump(jump),.branch(branch),.mem_read(mem_read),  
                .mem_write(mem_write),.alu_src(alu_src),.reg_write(reg_write));  //.alu_op(alu_op)
					 
 assign write_reg_address = (reg_dst==1'b0) ? instr[8:6] : instr[6:3]; // chon dia chi rd
 assign reg_read_addr_A = instr[11:9];  // dia chi doc register A va B
 assign reg_read_addr_B = instr[8:6];
 
 register_file reg_file(.clk(clk),.rst(reset),.reg_write_en(reg_write), // Enable write tá»« control unit  
                        .reg_write_dest(write_reg_address),  // Dia chi rd
                        .reg_write_data(write_reg_data),     // Data in rd
                        .reg_read_addr_1(reg_read_addr_A),  
                        .reg_read_data_1(reg_read_data_A),  
                        .reg_read_addr_2(reg_read_addr_B),  
                        .reg_read_data_2(reg_read_data_B));
 
 sign_extend sign_ext(.input_value(instr[5:0]), .output_value(sign_ext_im)); // Extend dau
 alu_control ALU_Control_unit(.Opcode(alu_op),.funct_in(instr[2:0]),.ALU_Funct(ALU_Control)); // ALU control
 assign read_dataB = (alu_src == 1'b1) ? sign_ext_im : reg_read_data_B; // Chon toan hang B = reg hay bang immediate
 alu alu_unit(.A(reg_read_data_A),.B(read_dataB),.Funct(ALU_Control),.ALU_result(ALU_out),.Zero(zero_flag), .Cout(cout));
 assign im_shift_1 = {sign_ext_im[6:0],1'b0}; // shift 1
 
 
 
 
 
 
 